{"ast":null,"code":"import _slicedToArray from \"C:/Users/sirvi/Documents/IT-tradenomikoulutus/OhjelmistoProjektiI/TicketGuru/ticketguruclient/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { ActionTypes } from './useListbox.types';\nimport areArraysEqual from '../utils/areArraysEqual';\n\n/**\n * Gets the current state. If the selectedValue is controlled,\n * the `value` prop is the source of truth instead of the internal state.\n */\nfunction getControlledState(internalState, props) {\n  if (props.value !== undefined) {\n    return _extends({}, internalState, {\n      selectedValue: props.value\n    });\n  }\n  return internalState;\n}\nfunction areOptionsEqual(option1, option2, optionComparer) {\n  if (option1 === option2) {\n    return true;\n  }\n  if (option1 === null || option2 === null) {\n    return false;\n  }\n  return optionComparer(option1, option2);\n}\n\n/**\n * Triggers change event handlers (onChange and onHighlightChange) when reducer returns changed state.\n *\n * @param nextState The next state returned by the reducer.\n * @param internalPreviousState The previous state. If the component is controlled, this is merged with the props to determine the final state.\n * @param propsRef The props with defaults applied.\n * @param lastActionRef The last action that was dispatched.\n */\nfunction useStateChangeDetection(nextState, internalPreviousState, propsRef, lastActionRef) {\n  React.useEffect(function () {\n    var _previousState$select;\n    if (!propsRef.current || lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n    if (lastActionRef.current.type === ActionTypes.setValue || lastActionRef.current.type === ActionTypes.setHighlight) {\n      // Don't fire change events when the value has been changed externally (e.g. by changing the controlled prop).\n      return;\n    }\n    var previousState = getControlledState(internalPreviousState, propsRef.current);\n    var _propsRef$current2 = propsRef.current,\n      optionComparer = _propsRef$current2.optionComparer,\n      onChange = _propsRef$current2.onChange;\n    var previousSelectedValues = (_previousState$select = previousState == null ? void 0 : previousState.selectedValues) != null ? _previousState$select : [];\n    var nextSelectedValues = nextState.selectedValues;\n    if (!areArraysEqual(nextSelectedValues, previousSelectedValues, optionComparer)) {\n      onChange == null ? void 0 : onChange(lastActionRef.current.event, nextSelectedValues);\n    }\n\n    // Fires the highlightChange event when reducer returns changed `highlightedValue`.\n    if (!areOptionsEqual(internalPreviousState.highlightedValue, nextState.highlightedValue, propsRef.current.optionComparer)) {\n      var _propsRef$current, _propsRef$current$onH;\n      (_propsRef$current = propsRef.current) == null ? void 0 : (_propsRef$current$onH = _propsRef$current.onHighlightChange) == null ? void 0 : _propsRef$current$onH.call(_propsRef$current, lastActionRef.current.event, nextState.highlightedValue);\n    }\n    lastActionRef.current = null;\n  }, [nextState.selectedValues, nextState.highlightedValue, internalPreviousState, propsRef, lastActionRef]);\n}\n\n/**\n * @ignore - do not document.\n */\nexport default function useControllableReducer(internalReducer, externalReducer, props) {\n  var _ref;\n  var _props$current = props.current,\n    value = _props$current.value,\n    defaultValue = _props$current.defaultValue;\n  var actionRef = React.useRef(null);\n  var initialSelectedValues = (_ref = value === undefined ? defaultValue : value) != null ? _ref : [];\n  var initialState = {\n    highlightedValue: null,\n    selectedValues: initialSelectedValues\n  };\n  var combinedReducer = React.useCallback(function (state, action) {\n    actionRef.current = action;\n    if (externalReducer) {\n      return externalReducer(getControlledState(state, action.props), action);\n    }\n    return internalReducer(getControlledState(state, action.props), action);\n  }, [externalReducer, internalReducer]);\n  var _React$useReducer = React.useReducer(combinedReducer, initialState),\n    _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n    nextState = _React$useReducer2[0],\n    dispatch = _React$useReducer2[1];\n  var dispatchWithProps = React.useCallback(function (action) {\n    dispatch(_extends({\n      props: props.current\n    }, action));\n  }, [dispatch, props]);\n  var previousState = React.useRef(initialState);\n  React.useEffect(function () {\n    previousState.current = nextState;\n  }, [previousState, nextState]);\n  useStateChangeDetection(nextState, previousState.current, props, actionRef);\n  return [getControlledState(nextState, props.current), dispatchWithProps];\n}","map":{"version":3,"names":["_extends","React","ActionTypes","areArraysEqual","getControlledState","internalState","props","value","undefined","selectedValue","areOptionsEqual","option1","option2","optionComparer","useStateChangeDetection","nextState","internalPreviousState","propsRef","lastActionRef","useEffect","_previousState$select","current","type","setValue","setHighlight","previousState","_propsRef$current2","onChange","previousSelectedValues","selectedValues","nextSelectedValues","event","highlightedValue","_propsRef$current","_propsRef$current$onH","onHighlightChange","call","useControllableReducer","internalReducer","externalReducer","_ref","_props$current","defaultValue","actionRef","useRef","initialSelectedValues","initialState","combinedReducer","useCallback","state","action","_React$useReducer","useReducer","_React$useReducer2","_slicedToArray","dispatch","dispatchWithProps"],"sources":["C:/Users/sirvi/Documents/IT-tradenomikoulutus/OhjelmistoProjektiI/TicketGuru/ticketguruclient/node_modules/@mui/base/useListbox/useControllableReducer.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { ActionTypes } from './useListbox.types';\nimport areArraysEqual from '../utils/areArraysEqual';\n\n/**\n * Gets the current state. If the selectedValue is controlled,\n * the `value` prop is the source of truth instead of the internal state.\n */\nfunction getControlledState(internalState, props) {\n  if (props.value !== undefined) {\n    return _extends({}, internalState, {\n      selectedValue: props.value\n    });\n  }\n  return internalState;\n}\nfunction areOptionsEqual(option1, option2, optionComparer) {\n  if (option1 === option2) {\n    return true;\n  }\n  if (option1 === null || option2 === null) {\n    return false;\n  }\n  return optionComparer(option1, option2);\n}\n\n/**\n * Triggers change event handlers (onChange and onHighlightChange) when reducer returns changed state.\n *\n * @param nextState The next state returned by the reducer.\n * @param internalPreviousState The previous state. If the component is controlled, this is merged with the props to determine the final state.\n * @param propsRef The props with defaults applied.\n * @param lastActionRef The last action that was dispatched.\n */\nfunction useStateChangeDetection(nextState, internalPreviousState, propsRef, lastActionRef) {\n  React.useEffect(() => {\n    var _previousState$select;\n    if (!propsRef.current || lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n    if (lastActionRef.current.type === ActionTypes.setValue || lastActionRef.current.type === ActionTypes.setHighlight) {\n      // Don't fire change events when the value has been changed externally (e.g. by changing the controlled prop).\n      return;\n    }\n    const previousState = getControlledState(internalPreviousState, propsRef.current);\n    const {\n      optionComparer,\n      onChange\n    } = propsRef.current;\n    const previousSelectedValues = (_previousState$select = previousState == null ? void 0 : previousState.selectedValues) != null ? _previousState$select : [];\n    const nextSelectedValues = nextState.selectedValues;\n    if (!areArraysEqual(nextSelectedValues, previousSelectedValues, optionComparer)) {\n      onChange == null ? void 0 : onChange(lastActionRef.current.event, nextSelectedValues);\n    }\n\n    // Fires the highlightChange event when reducer returns changed `highlightedValue`.\n    if (!areOptionsEqual(internalPreviousState.highlightedValue, nextState.highlightedValue, propsRef.current.optionComparer)) {\n      var _propsRef$current, _propsRef$current$onH;\n      (_propsRef$current = propsRef.current) == null ? void 0 : (_propsRef$current$onH = _propsRef$current.onHighlightChange) == null ? void 0 : _propsRef$current$onH.call(_propsRef$current, lastActionRef.current.event, nextState.highlightedValue);\n    }\n    lastActionRef.current = null;\n  }, [nextState.selectedValues, nextState.highlightedValue, internalPreviousState, propsRef, lastActionRef]);\n}\n\n/**\n * @ignore - do not document.\n */\nexport default function useControllableReducer(internalReducer, externalReducer, props) {\n  var _ref;\n  const {\n    value,\n    defaultValue\n  } = props.current;\n  const actionRef = React.useRef(null);\n  const initialSelectedValues = (_ref = value === undefined ? defaultValue : value) != null ? _ref : [];\n  const initialState = {\n    highlightedValue: null,\n    selectedValues: initialSelectedValues\n  };\n  const combinedReducer = React.useCallback((state, action) => {\n    actionRef.current = action;\n    if (externalReducer) {\n      return externalReducer(getControlledState(state, action.props), action);\n    }\n    return internalReducer(getControlledState(state, action.props), action);\n  }, [externalReducer, internalReducer]);\n  const [nextState, dispatch] = React.useReducer(combinedReducer, initialState);\n  const dispatchWithProps = React.useCallback(action => {\n    dispatch(_extends({\n      props: props.current\n    }, action));\n  }, [dispatch, props]);\n  const previousState = React.useRef(initialState);\n  React.useEffect(() => {\n    previousState.current = nextState;\n  }, [previousState, nextState]);\n  useStateChangeDetection(nextState, previousState.current, props, actionRef);\n  return [getControlledState(nextState, props.current), dispatchWithProps];\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}